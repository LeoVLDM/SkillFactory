"""
Скрипт демонстрирует угадывание числа и нахождение среднего количества попыток при угадывании.
"""

import numpy as np  # импортируем "Фундаментальный пакет для научных вычислений с Python"


debug: bool = False  # переключение режима тестирования,
# при котором выводятся промежуточные значения во время выполнения без debug-режима
# нужно было устранить баги и найти оптимальное решение, которое было найдено путём округления
# баги были в виде бесконечного выполнения цикла для определённых чисел


def score_game(game_core):
    """ Функция для прогона алгоритмов.
        Запускаем игру 1000 раз, чтобы узнать, как быстро игра угадывает число.
    """
    count_ls = []  # в этот список будем добавлять значения с количеством произведённых попыток
    np.random.seed(1)  # фиксируем RANDOM SEED, чтобы ваш эксперимент был воспроизводим!
    random_array = np.random.randint(1, 101, size=1000)  # массив из тысячи случайных чисел от 1 до 100

    if debug:  # в режиме отладки выводим массив случайных чисел, для наглядности
        print(random_array)

    for number in random_array:  # цикл перебора всех случайных чисел
        count_ls.append(game_core(number))  # запускаем нашу функцию и добавляем результат выполнения в массив
        if debug:  # вывод текущего числа в режиме отладки
            print(number)

    score = np.mean(count_ls)  # получаем среднее число попыток, не целое - чтобы поточнее
    score_max = np.max(count_ls)  # максимальное число попыток
    # score_min = np.min(count_ls)  # минимальное число попыток, не имеет значения, всегда равно единице

    # вывести в консоль результат
    print(f"Ваш алгоритм угадывает число в среднем за {score} попыток. "
          f"Из них максимальных - {score_max}")  # , минимальных - {score_min}")
    return score  # возвращаем результат работы функции в виде среднего числа попыток


def game_core_v1(number):
    """ Первая версия. Взята из обучающего материала как пример.
        Просто угадываем на random, никак не используя информацию о больше или меньше.
        Функция принимает загаданное число и возвращает число попыток
    """
    count = 0  # счётчик попыток
    while True:
        count += 1
        predict = np.random.randint(1, 101)  # предполагаемое число
        if number == predict:
            return count  # если угадали, возврат функции количества использованных попыток


def game_core_v2(number):
    """ Вторая версия. Взята из обучающего материала как пример.
        Сначала устанавливаем любое random число, а потом уменьшаем или увеличиваем его в зависимости от того,
        больше оно или меньше нужного.
        Функция принимает загаданное число и возвращает число попыток
    """
    count = 1  # счётчик попыток
    predict = np.random.randint(1, 101)  # предполагаемое число
    while number != predict:  # запускаем цикл до тех пор, пока загаданное число не совпадёт с предполагаемым
        count += 1  # прибавляем счётчик
        if number > predict:
            predict += 1  # если загаданное числе больше предполагаемого, прибавляем на единицу
        elif number < predict:
            predict -= 1  # если загаданное число меньше предполагаемого, уменьшаем на единицу
    return count  # если угадали, возврат функции количества использованных попыток


def divide_method(number):
    """ Функция для итогового задания.
        Функция принимает загаданное число и возвращает число попыток.

        Краткое описание алгоритма.
        Делим заданный диапазон пополам, находим предполагаемое число.
        По условию отбрасываем ненужную часть диапазона.
        Вычисляем следующее предполагаемое число.
        И так по циклу, до совпадения предполагаемого числа с загаданным.
    """
    count = 1           # счётчик попыток, первая попытка вне основного цикла
    min_num = 1         # минимальное число, заданное условием
    max_num = 100       # максимальное число, заданное условием
    predict = (max_num + 1 - min_num) // 2  # первое вычисление, делим весь диапазон пополам без остатка,
    # тем самым получаем первое предполагаемое число
    middle_value = 0    # вычисляемое серединное значение от текущего диапазона
    symbol = ""         # вывод символа < или > для наглядности во время тестирования

    while number != predict:    # основной цикл, при условии которого выполняется алгоритм
        count += 1              # прибавляем счётчик попыток

        if number > predict:    # условие если загаданное число больше предполагаемого
            min_num = predict   # отбрасываем половину диапазона, используя предыдущее предполагаемое число
            middle_value = int((max_num - min_num) / 2) | 1     # делим диапазон пополам
            # здесь будем отбрасывать остаток, чтобы число было ближе к минимуму текущего диапазона
            # в случае получения нулевого значения, заменяем единицей, используя побитовый логический оператор
            predict += middle_value     # прибавляем к предыдущему предполагаемому числу вычисленную середину
            symbol = ">"        # символ для визуального обозначения сработавшего условия в режиме теста

        elif number < predict:  # условие, если загаданное число меньше предполагаемого
            max_num = predict   # отбрасываем половину диапазона, используя предыдущее предполагаемое число
            middle_value = round((max_num - min_num) / 2) | 1     # делим диапазон пополам
            # здесь будем округлять до целого, чтобы число было ближе к максимуму текущего диапазона
            # в случае получения нулевого значения, заменяем единицей, используя побитовый логический оператор
            predict -= middle_value     # убавляем от предыдущего предполагаемого числа вычисленную середину
            symbol = "<"        # символ для визуального обозначения сработавшего условия в режиме теста

        if debug:   # наглядный вывод текущих полученных значений для режима теста
            print(f"{count}:\t"
                  f"{number} {symbol} {predict}\t\t"
                  f"middle={middle_value}\t\t"
                  f"min={min_num}\t"
                  f"max={max_num}"
                  )
        if count > 1000:
            exit(1)  # завершение скрипта с кодом выхода, в случае если цикл не прекращается

    return count    # если угадали, возврат функции количества использованных попыток


# Тестирование
# divide_method(73)

# запускаем первые два примера
print("\nПервая версия. Случайные числа.")
score_game(game_core_v1)
print("\nВторая версия. Двусторонний перебор от случайного числа.")
score_game(game_core_v2)

# запуск функции с алгоритмом, написанного для итогового задания
print("\nМетод отбрасывания половины. Это наименьшее число попыток.")
score_game(divide_method)
# В моём случае, был выдан такой результат:
# Ваш алгоритм угадывает число в среднем за 6.168 попыток. Из них максимальных - 9

exit(0)
